2023-01-10
Programmers의 문제를 가지고 온것 입니다. 
# 문제 설명

## 전력망을 둘로 나누기
### 문제 설명
n개의 송전탑이 전선을 통해 하나의 **트리 형태**로 연결되어 있습니다. 
당신은 이 전선들 중 하나를 끊어서 현재의 전력망 네트워크를 **2개로 분할**하려고 합니다. 
이때, 두 전력망이 갖게 되는 송전탑의 개수를 최대한 비슷하게 맞추고자 합니다.

송전탑의 개수 n, 그리고 전선 정보 wires가 매개변수로 주어집니다. 
전선들 중 하나를 끊어서 송전탑 개수가 가능한 비슷하도록 두 전력망으로 나누었을 때, 
두 전력망이 가지고 있는 송전탑 개수의 차이(절대값)를 return 하도록 solution 함수를 완성해주세요.

### 제한사항
* n은 2 이상 100 이하인 자연수입니다.  
* wires는 길이가 n-1인 정수형 2차원 배열입니다.
   - wires의 각 원소는 [v1, v2] 2개의 자연수로 이루어져 있으며, 
     이는 전력망의 v1번 송전탑과 v2번 송전탑이 전선으로 연결되어 있다는 것을 의미합니다.
   - 1 ≤ v1 < v2 ≤ n 입니다.
   - 전력망 네트워크가 하나의 트리 형태가 아닌 경우는 입력으로 주어지지 않습니다.

### 입출력 예
|n|wires|result|
|------|---|---|
|9|[[1,3],[2,3],[3,4],[4,5],[4,6],[4,7],[7,8],[7,9]]|3|
|4|[[1,2],[2,3],[3,4]]|0|
|7|[[1,2],[2,7],[3,7],[3,4],[4,5],[6,7]]|1|

### 입출력 예 설명
#### 입출력 예 #1
* 다음 그림은 주어진 입력을 해결하는 방법 중 하나를 나타낸 것입니다.
![image](https://user-images.githubusercontent.com/71332005/211486992-f20a46f6-2d01-4d5c-b1f2-96cf5be6d036.png)

* 4번과 7번을 연결하는 전선을 끊으면 두 전력망은 각 6개와 3개의 송전탑을 가지며, 
  이보다 더 비슷한 개수로 전력망을 나눌 수 없습니다.
* 또 다른 방법으로는 3번과 4번을 연결하는 전선을 끊어도 최선의 정답을 도출할 수 있습니다.

#### 입출력 예 #2
* 다음 그림은 주어진 입력을 해결하는 방법을 나타낸 것입니다.
![image](https://user-images.githubusercontent.com/71332005/211487201-900661b4-f91c-4523-8c88-d483703e3b24.png)
* 2번과 3번을 연결하는 전선을 끊으면 두 전력망이 모두 2개의 송전탑을 가지게 되며, 
  이 방법이 최선입니다.

#### 입출력 예 #3
* 다음 그림은 주어진 입력을 해결하는 방법을 나타낸 것입니다.
![image](https://user-images.githubusercontent.com/71332005/211487305-88e71bd9-6188-4a46-9edb-e89bbe684b7e.png)
* 3번과 7번을 연결하는 전선을 끊으면 두 전력망이 각각 4개와 3개의 송전탑을 가지게 되며, 
  이 방법이 최선입니다.

# 문제 해결
## 트리 형태 
트리는 나무의 뿌리와 같이 하나의 루트(Root)를 가지고 아래로 퍼져 내려가는 형태를 가진다.  
트리의 형태와 관련된 용어를 간단히 잘 설명 되어있는 그림이다.  
![tree-terms](https://user-images.githubusercontent.com/71332005/211489783-01b7d267-8695-4983-978e-e3cb6eb7bda2.png)

* **루트 노드(Root node)** : 부모노드, 즉 상위 노드가 없는 최상위에 있는 노드이며 트리는 하나의 루트 노드만 가진다.
* **부모 노드(Parent node)** : 노드의 상위 노드이며 부모 노드가 없는 루트노드를 제외하고 모든 노드는 하나의 부모 노드를 가진다.
* **자식 노드(Child node)** : 하나의 노드의 하위 노드를 뜻한다.
* **리프 노드(Leaf node)** : 또는 외부 노드(External node)라고도 하며 자식 노드가 없는 노드이다.
* **형제(Sibling)** : 같은 부모를 가지는 노드들이다.
* **노드의 크기(Size)** : 자신을 포함하는 모든 하위 노드(자손 노드)들의 개수이다.
* **노드의 깊이(Depth)** : 루트부터 노드까지 최소의 간선(Edge) 개수이다. 
* **노드의 차수(Degree)** : 노드의 자식 노드의 개수이다. 
* **트리의 차수(Degree of tree)** : 트리 내의 최대 차수를 의미한다.
* **트리의 높이(height)** : 루트 노드로부터 가장 먼 노드의 깊이를 의미한다.

### 트리가 아닌것
트리가 아닌 것을 보니 트리가 더욱 와닿아 정리한다.
![image](https://user-images.githubusercontent.com/71332005/211497930-2a0ea925-f964-4e2b-9e3e-8ece653c93f6.png)
* Case 1(**트리가 아님**) : 하나의 트리가 아니다. A-B와 C-D-E 두개의 트리로 하나의 트리는 모든 노                             드들이 연결되어있어야 한다.
* Case 2(**트리가 아님**) : (Undirected cycle)무향 순환을 이루며, 둘 이상의 부모노드를 가질 수 없다. D노드의 부모가 B, C 둘 이므로 트리가 아니다.
* Case 3(**트리가 아님**) : (Cycle)순환 구조이며, B의 부모가 A, D 이므로 트리가 아니다.
* Case 4(**트리가 아님**) : A-A를 순환하며, A노드가 루트이지만 부모 A가 있기에 트리가 아니다.
* Case 5(**트리**) : 간단한 트리 형태이다.

### 위 문제 구조는 트리구조를 가지고 있으므로 어떠한 Wire을 나누어도 2개로 나누어 진다. 

## 완전 탐색
모든 경우의 수를 탐색하는 방법이다. 송전탑의 개수가 100개 이하이므로 실행시간에 큰 문제는 없어보인다.
### 깊이 우선 탐색(Depth-First Search, DFS), 너비 우선 탐색(Breadth-First Search, BFS)
* 깊이 우선 탑색과 너비 우선 탐색의 탐색방법은 아래 GIF로 간단히 이해가 갈 것이다. 
<img src="https://media.vlpt.us/images/hyehyes/post/06969134-f30c-47ca-a1bd-24449b0ed055/997C3C3E5BD01AF41D.gif">

## 나의 접근 
Union Find 알고리즘을 보고 아이디어를 얻어 작성해보았다. 
1. `wires`에서 연결을 하나씩 끊어가며 확인 할 것이다.  
2. 연결을 끊으면 두 개의 트리가 나오고 연결들의 조상을 저장하며 하위 노드들의 개수를 카운트 한다.
3. 부모노드가 없는 노드의 하위 노드의 개수의 차이를 구한다.

코드 
```
def find (x,parent):
    # x 노드의 부모노드가 x 이면 root노드이다.
    if parent[x][0] == x:
        return x
    else:
        # 각 노드의 부모노드을 저장
        parent[x][0] = find(parent[x][0],parent)
        return  parent[x][0]

def union(a,b,parent,root):
    A = find(a,parent) #a가 속한 root 노드을 찾는다.
    B = find(b,parent) #b가 속한 root 노드을 찾는다.
    
    parent[B][0] = A # b의 루트 노드를 a의 루트노드로 설정.
    parent[A][1] += parent[B][1]+1 #a의 루트노드에 b의 루트노드의 하위노드 개수를 포함.
    # a의 루트노드에 하위 노드로 포함된 b의 루트노드를 루트가 아님으로 설정.
    root[B] = 0
    
    return parent

def solution(n, wires):
    answer = 100
    
    for i in range(len(wires)):
        parent = [[j,0] for j in range(n+1)]
        root = [1 for j in range(n+1)]
        
        # wire를 하나씩 끊어가며 확인
        for a, b in (wires[:i] + wires[i+1:]):
            parent = union(a,b,parent,root)

        ans = 0
        for i in range(1,n+1):
            # root 리스트에서 부모노드가 없는 노드만 1로 설정되어 있음.
            a = parent[i][1]*root[i]
            # 루트노드는 2개 이므로 최대 두번 if문을 들어간다.
            if a != 0:
                ans += a # 처음 if문에 들어와서 ans에 a를 더함
                ans = -ans # 두번째 올 때에는 a에 -ans를 를 더하기 위함.
        # 절대값이 가장 작은 결과를 채택             
        if answer > abs(ans):
            answer = abs(ans)
            
    return answer                       
```

 
